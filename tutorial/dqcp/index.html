
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>Disciplined Quasiconvex Programming &#8212; CVXPY 1.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/cvxpy_alabaster.css" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Advanced Features" href="../advanced/index.html" />
    <link rel="prev" title="Disciplined Geometric Programming" href="../dgp/index.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="disciplined-quasiconvex-programming">
<span id="dqcp"></span><h1>Disciplined Quasiconvex Programming<a class="headerlink" href="#disciplined-quasiconvex-programming" title="Permalink to this headline">¶</a></h1>
<p>Disciplined quasiconvex programming (DQCP) is a generalization of DCP for
quasiconvex functions. Quasiconvexity generalizes convexity: a function
<span class="math notranslate nohighlight">\(f\)</span> is quasiconvex if and only if its domain is a convex set and its
sublevel sets <span class="math notranslate nohighlight">\(\{x : f(x) \leq t\}\)</span> are convex, for all <span class="math notranslate nohighlight">\(t\)</span>. For a
thorough overview of quasiconvexity, see the paper <a class="reference external" href="https://web.stanford.edu/~boyd/papers/dqcp.html">Disciplined quasiconvex programming</a>.</p>
<p>While DCP is a ruleset for constructing convex programs, DQCP
is a ruleset for quasiconvex programs (QCPs), which are optimization problems
in which the objective is to minimize a quasiconvex function over a convex
set. The convex set can be specified using equalities of affine functions
and inequalities of convex and concave functions, just as in DCP; additionally,
DQCP permits inequalities of the form <span class="math notranslate nohighlight">\(f(x) \leq t\)</span>, where <cite>f(x)</cite> is
a quasiconvex expression and <span class="math notranslate nohighlight">\(t\)</span> is constant, and <span class="math notranslate nohighlight">\(f(x) \geq t\)</span>,
where <cite>f(x)</cite> is quasiconcave and <span class="math notranslate nohighlight">\(t\)</span> is constant. Every disciplined
convex program is a disciplined quasiconvex program, but the converse is not
true.</p>
<p>CVXPY lets you form and solve DQCP problems, just as it does for DCP
problems. For example, the following code solves a simple QCP,</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="nn">cp</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">()</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">objective_fn</span> <span class="o">=</span> <span class="o">-</span><span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">y</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Minimize</span><span class="p">(</span><span class="n">objective_fn</span><span class="p">),</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">])</span>
<span class="n">problem</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">qcp</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">problem</span><span class="o">.</span><span class="n">is_dqcp</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Optimal value: &quot;</span><span class="p">,</span> <span class="n">problem</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x: &quot;</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;y: &quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>and it prints the below output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Optimal</span> <span class="n">value</span><span class="p">:</span>  <span class="o">-</span><span class="mf">0.4288821220397949</span>
<span class="n">x</span><span class="p">:</span>  <span class="mf">0.49999737143004713</span>
<span class="n">y</span><span class="p">:</span>  <span class="mf">1.648717724845007</span>
</pre></div>
</div>
<p>To solve DQCP problems, you must pass the option
<code class="docutils literal notranslate"><span class="pre">qcp=True</span></code> to the <code class="docutils literal notranslate"><span class="pre">solve()</span></code> method.</p>
<p>This section explains what DQCP is, and it shows how to construct and solve DQCP
problems using CVXPY. At the end of the section are tables listing all the
atoms that can be used in DQCP problems, similar to the tables presented in
the section on <a class="reference internal" href="../functions/index.html#functions"><span class="std std-ref">DCP atoms</span></a>.</p>
<p>For an in-depth reference on DQCP, see our
<a class="reference external" href="https://web.stanford.edu/~boyd/papers/dqcp.html">accompanying paper</a>.
For interactive code examples, check out our <a class="reference internal" href="../../examples/index.html#dqcp-examples"><span class="std std-ref">notebooks</span></a>.</p>
<p><em>Note: DQCP is a recent addition to CVXPY. If you have feedback, please file an
issue or make a pull request on</em> <a class="reference external" href="https://github.com/cvxpy/cvxpy">Github</a>.</p>
<section id="curvature">
<h2>Curvature<a class="headerlink" href="#curvature" title="Permalink to this headline">¶</a></h2>
<p>DQCP adds two new types of curvature to CVXPY: quasiconvex and quasiconcave. A
function <span class="math notranslate nohighlight">\(f\)</span> is quasiconvex if and only if its domain is a convex set and
its sublevel sets <span class="math notranslate nohighlight">\(\{x : f(x) \leq t\}\)</span> are convex, for all <span class="math notranslate nohighlight">\(t\)</span>;
<span class="math notranslate nohighlight">\(f\)</span> is quasiconcave if <span class="math notranslate nohighlight">\(-f\)</span> is quasiconvex. Every convex function
is also quasiconvex, and every concave function is also quasiconcave; the
converses of these statements are not true. An expression that is both
quasiconvex and quasiconcave is called quasilinear.</p>
<p>CVXPY’s curvature analysis can flag
Expressions as unknown even when they are quasiconvex or quasiconcave, but
it will never mistakenly flag an expression as quasiconvex or quasiconcave.</p>
<p>The curvature of an Expression is stored in its
<code class="code docutils literal notranslate"><span class="pre">.curvature</span></code> attribute. For example, running the following
script</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="nn">cp</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">z</span> <span class="o">=</span> <span class="o">-</span><span class="n">y</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">curvature</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">z</span><span class="o">.</span><span class="n">curvature</span><span class="p">)</span>

<span class="n">w</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">curvature</span><span class="p">)</span>
</pre></div>
</div>
<p>prints the following output.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">QUASICONVEX</span>
<span class="n">QUASICONCAVE</span>
<span class="n">QUASILINEAR</span>
</pre></div>
</div>
<p>You can also check the curvature of an Expression by
calling the methods <code class="code docutils literal notranslate"><span class="pre">is_quasiconvex()</span></code> and <code class="code docutils literal notranslate"><span class="pre">is_quasiconcave()</span></code>. For
example, <code class="code docutils literal notranslate"><span class="pre">y.is_quasiconvex()</span></code> and <code class="code docutils literal notranslate"><span class="pre">z.is_quasiconcave()</span></code> would
evaluate to <code class="code docutils literal notranslate"><span class="pre">True</span></code>. You can check if an expression is quasilinear by
calling the <code class="code docutils literal notranslate"><span class="pre">is_quasilinear()</span></code> method.</p>
</section>
<section id="composition-rules">
<h2>Composition rules<a class="headerlink" href="#composition-rules" title="Permalink to this headline">¶</a></h2>
<p>DQCP analysis is based on applying a general composition theorem from
convex analysis to each expression. An expression is verifiably
quasiconvex under DQCP if it is one of the following:</p>
<ul class="simple">
<li><p>convex (under DCP);</p></li>
<li><p>a quasiconvex atom, applied to a variable or constant:</p></li>
<li><p>the max (<code class="code docutils literal notranslate"><span class="pre">cvxpy.maximum</span></code>) of quasiconvex expressions;</p></li>
<li><p>an increasing function of a quasiconvex expression, or a decreasing function
of a quasiconcave expression;</p></li>
<li><p>an expression of the form <span class="math notranslate nohighlight">\(f(e_1, e_2, \ldots, e_n)\)</span> such
that (1) <span class="math notranslate nohighlight">\(f\)</span> is a quasiconvex atom, and (2) for each <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(f\)</span> is
increasing in argument <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(e_i\)</span> is convex, <span class="math notranslate nohighlight">\(f\)</span> is
decreasing in argument <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(e_i\)</span> is concave, or <span class="math notranslate nohighlight">\(e_i\)</span>
is affine.</p></li>
</ul>
<p>An expression is quasiconcave under DQCP if it is one of the following:</p>
<ul class="simple">
<li><p>concave (under DCP);</p></li>
<li><p>a quasiconcave atom, applied to a variable or constant:</p></li>
<li><p>the min (<code class="code docutils literal notranslate"><span class="pre">cvxpy.minimum</span></code>) of quasiconcave expressions;</p></li>
<li><p>an increasing function of a quasiconcave expression, or a decreasing function
of a quasiconvex expression;</p></li>
<li><p>an expression of the form <span class="math notranslate nohighlight">\(f(e_1, e_2, \ldots, e_n)\)</span> such
that (1) <span class="math notranslate nohighlight">\(f\)</span> is a quasiconcave atom, and (2) for each <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(f\)</span> is
increasing in argument <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(e_i\)</span> is concave, <span class="math notranslate nohighlight">\(f\)</span> is
decreasing in argument <span class="math notranslate nohighlight">\(i\)</span> and <span class="math notranslate nohighlight">\(e_i\)</span> is convex, or <span class="math notranslate nohighlight">\(e_i\)</span>
is affine.</p></li>
</ul>
<p>Whether an atom is quasiconvex or quasiconcave may depend on the signs of its
arguments. For example, the scalar product <span class="math notranslate nohighlight">\(xy\)</span> is quasiconcave when <cite>x</cite>
and <cite>y</cite> are either both nonnegative or both nonpositive, and quasiconvex when
one the arguments is nonnegative and the other is nonpositive.</p>
<p>If an Expression satisfies the above rules, we colloquially say that
the Expression “is DQCP.” You can check whether an Expression is DQCP
by calling the method <code class="code docutils literal notranslate"><span class="pre">is_dqcp()</span></code>. For example, the assertions
in the following code block will pass.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="nn">cp</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">product</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

<span class="k">assert</span> <span class="n">product</span><span class="o">.</span><span class="n">is_quasiconcave</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">product</span><span class="o">.</span><span class="n">is_dqcp</span><span class="p">()</span>
</pre></div>
</div>
<p>An Expression is DQCP precisely when it has known curvature, which means
at least one of the methods <code class="code docutils literal notranslate"><span class="pre">is_constant()</span></code>
<code class="code docutils literal notranslate"><span class="pre">is_affine()</span></code>, <code class="code docutils literal notranslate"><span class="pre">is_convex()</span></code>,
<code class="code docutils literal notranslate"><span class="pre">is_concave()</span></code>, <code class="code docutils literal notranslate"><span class="pre">is_quasiconvex()</span></code>, <code class="code docutils literal notranslate"><span class="pre">is_quasiconvex()</span></code> will
return <code class="code docutils literal notranslate"><span class="pre">True</span></code>.</p>
</section>
<section id="dqcp-problems">
<h2>DQCP problems<a class="headerlink" href="#dqcp-problems" title="Permalink to this headline">¶</a></h2>
<p>A <a class="reference internal" href="../../api_reference/cvxpy.problems.html#cvxpy.Problem" title="cvxpy.problems.problem.Problem"><code class="xref py py-class docutils literal notranslate"><span class="pre">Problem</span></code></a> is constructed from an objective and
a list of constraints. If a problem follows the DQCP rules, it is guaranteed to
be a DQCP and solvable by CVXPY (if a solution to the problem exists). The DQCP
rules require that the problem objective have one of two forms:</p>
<ul class="simple">
<li><p>Minimize(quasiconvex)</p></li>
<li><p>Maximize(quasiconcave)</p></li>
</ul>
<p>The only valid constraints under the DQCP rules are</p>
<ul class="simple">
<li><p>affine == affine</p></li>
<li><p>convex &lt;= concave</p></li>
<li><p>concave &gt;= convex</p></li>
<li><p>quasiconvex &lt;= constant</p></li>
<li><p>quasiconcave &gt;= constant</p></li>
</ul>
<p>You can check that a problem, constraint, or objective satisfies the DQCP
rules by calling <code class="docutils literal notranslate"><span class="pre">object.is_dqcp()</span></code>. Here are some examples of DQCP and
non-DQCP problems:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cvxpy</span> <span class="k">as</span> <span class="nn">cp</span>

<span class="c1"># The sign of variables affects curvature analysis.</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">(</span><span class="n">nonneg</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">concave_fractional_fn</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">constraint</span> <span class="o">=</span> <span class="p">[</span><span class="n">cp</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">]</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Maximize</span><span class="p">(</span><span class="n">concave_fractional_fn</span><span class="p">),</span> <span class="n">constraint</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">concave_fractional_fn</span><span class="o">.</span><span class="n">is_quasiconcave</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">constraint</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">is_dqcp</span><span class="p">()</span>
<span class="k">assert</span> <span class="n">problem</span><span class="o">.</span><span class="n">is_dqcp</span><span class="p">()</span>

<span class="n">w</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Variable</span><span class="p">()</span>
<span class="n">fn</span> <span class="o">=</span> <span class="n">w</span> <span class="o">*</span> <span class="n">cp</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
<span class="n">problem</span> <span class="o">=</span> <span class="n">cp</span><span class="o">.</span><span class="n">Problem</span><span class="p">(</span><span class="n">cp</span><span class="o">.</span><span class="n">Maximize</span><span class="p">(</span><span class="n">fn</span><span class="p">))</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">fn</span><span class="o">.</span><span class="n">is_dqcp</span><span class="p">()</span>
<span class="k">assert</span> <span class="ow">not</span> <span class="n">problem</span><span class="o">.</span><span class="n">is_dqcp</span><span class="p">()</span>
</pre></div>
</div>
<p>CVXPY will raise an exception if you call <code class="docutils literal notranslate"><span class="pre">problem.solve(qcp=True)</span></code> on a
non-DQCP problem.</p>
</section>
<section id="dqcp-atoms">
<span id="id2"></span><h2>DQCP atoms<a class="headerlink" href="#dqcp-atoms" title="Permalink to this headline">¶</a></h2>
<p>Quasiconvex and quasiconcave expressions can be constructed using
convex and concave atoms, using the curvature rules given above.
This section describes new semantics for some existing atoms under DQCP,
and introduces new atoms that are quasiconvex or quasiconcave (but not
convex or concave). Many of these new atoms are integer-valued.</p>
<p><strong>Ratio.</strong> The infix operator <code class="docutils literal notranslate"><span class="pre">/</span></code> is an atom, denoting ratio. This atom
is both quasiconvex and quasiconcave when the denominator is known to be
either nonnegative or nonpositive. The ratio <code class="docutils literal notranslate"><span class="pre">x/y</span></code> is increasing in <code class="docutils literal notranslate"><span class="pre">x</span></code>
when <code class="docutils literal notranslate"><span class="pre">y</span></code> is nonnegative, increasing in <code class="docutils literal notranslate"><span class="pre">y</span></code> when <code class="docutils literal notranslate"><span class="pre">x</span></code> is nonpositive,
decreasing in <code class="docutils literal notranslate"><span class="pre">x</span></code> when <code class="docutils literal notranslate"><span class="pre">y</span></code> is nonpositive, and decreasing in <code class="docutils literal notranslate"><span class="pre">y</span></code>
when <code class="docutils literal notranslate"><span class="pre">x</span></code> is nonnegative.</p>
<p>The ratio atom can be used with the composition rule to construct interesting
quasiconvex and quasiconcave expressions. For example, the ratio of a
nonnegative concave function and a positive convex function is quasiconcave,
and the ratio of a nonnegative convex function and a positive concave function
is quasiconvex. Similarly, the ratio of two affine functions is quasilinear
when the denominator is positive.</p>
<p><strong>Scalar product.</strong>
The scalar product <code class="docutils literal notranslate"><span class="pre">*</span></code> is quasiconvex when one of its arguments is
nonnegative and the other is nonpositive, and it is quasiconcave when its
arguments are both nonnegative or both nonpositive. Hence, by the composition
rule, the product of two nonnegative concave functions is quasiconcave,
and the product of a nonnegative concave function and a nonpositive convex
function is quasiconvex.</p>
<p><strong>Distance ratio function.</strong>
The atom <code class="docutils literal notranslate"><span class="pre">cvxpy.dist_ratio(x,</span> <span class="pre">a,</span> <span class="pre">b)</span></code> denotes the function
<span class="math notranslate nohighlight">\(\|x - a\|_2 / \|x - b\|_2\)</span>, implicitly enforcing the constraint
that <span class="math notranslate nohighlight">\(\|x - a\|_2 \leq \|x - b\|_2\)</span>. The expressions <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>
must be constants. This atom is quasiconvex.</p>
<p><strong>Maximum generalized eigenvalue.</strong>
The atom <code class="docutils literal notranslate"><span class="pre">cvxpy.gen_lambda_max(A,</span> <span class="pre">B)</span></code> computes the maximum
generalized eigenvalue of <code class="docutils literal notranslate"><span class="pre">A</span></code> and <code class="docutils literal notranslate"><span class="pre">B</span></code>, defined as the maximum
<span class="math notranslate nohighlight">\(\lambda \in \mathbf{R}\)</span> such that <span class="math notranslate nohighlight">\(Ax = \lambda Bx\)</span> for some <span class="math notranslate nohighlight">\(x\)</span>.
This atom is quasiconvex, and it enforces the constraint that <code class="docutils literal notranslate"><span class="pre">A</span></code> is
symmetric and <code class="docutils literal notranslate"><span class="pre">B</span></code> is positive definite.</p>
<p><strong>Ceiling and floor.</strong>
The atoms <code class="docutils literal notranslate"><span class="pre">cvxpy.ceil(x)</span></code> and <code class="docutils literal notranslate"><span class="pre">cvxpy.floor(x)</span></code> are quasilinear, and
increasing in their arguments.</p>
<p><strong>Sign.</strong>
The atoms <code class="docutils literal notranslate"><span class="pre">cvxpy.sign(x)</span></code>, which returns <code class="docutils literal notranslate"><span class="pre">-1</span></code> for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">0</span></code> and <code class="docutils literal notranslate"><span class="pre">+1</span></code>
for <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, is quasilinear.</p>
<p><strong>Length of a vector.</strong>
The atoms <code class="docutils literal notranslate"><span class="pre">cvxpy.length(x)</span></code>, which returns the index of the last nonzero
element in <span class="math notranslate nohighlight">\(x \in \mathbf{R}^n\)</span>, is quasiconvex.</p>
</section>
<section id="solving-dqcp-problems">
<h2>Solving DQCP problems<a class="headerlink" href="#solving-dqcp-problems" title="Permalink to this headline">¶</a></h2>
<p>A DQCP problem <code class="docutils literal notranslate"><span class="pre">problem</span></code> can be solved by calling <code class="docutils literal notranslate"><span class="pre">problem.solve(qcp=True)</span></code>.
CVXPY uses a bisection method on the optimal value of the problem to solve
QCPs, and it will automatically find an upper and lower bound for the
bisection. You can optionally provide your own upper and lower bound when
solving a QCP, which can sometimes be helpful. You can provide these bounds via
the keyword arguments <code class="docutils literal notranslate"><span class="pre">low</span></code> and <code class="docutils literal notranslate"><span class="pre">high</span></code>; for example,
<code class="docutils literal notranslate"><span class="pre">problem.solve(qcp=True,</span> <span class="pre">low=12,</span> <span class="pre">high=17)</span></code> would limit the bisection to
objective values that are greater than 12 and less than 17.</p>
<p>Bisection involves solving a sequence of optimization problems. If your problem
is ill-conditioned, or if you’re unlucky, a solver might fail to solve one
of these subproblems, which will result in an error. If this happens,
you can try using a different solver via the <code class="docutils literal notranslate"><span class="pre">solver</span></code> keyword argument. (For
example, <code class="docutils literal notranslate"><span class="pre">problem.solve(qcp=True,</span> <span class="pre">solver=cp.SCS)</span></code>.) To obtain
verbose output describing the bisection, supply the keyword argument
<code class="docutils literal notranslate"><span class="pre">verbose=True</span></code> to the solve method (<code class="docutils literal notranslate"><span class="pre">problem.solve(qcp=True,</span>
<span class="pre">verbose=True)</span></code>).</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">CVXPY</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=cvxpy&repo=cvxpy&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Install</a></li>
</ul>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">User Guide</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../intro/index.html">What is CVXPY?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dcp/index.html">Disciplined Convex Programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../functions/index.html">Atomic Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../dgp/index.html">Disciplined Geometric Programming</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Disciplined Quasiconvex Programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#curvature">Curvature</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composition-rules">Composition rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dqcp-problems">DQCP problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dqcp-atoms">DQCP atoms</a></li>
<li class="toctree-l3"><a class="reference internal" href="#solving-dqcp-problems">Solving DQCP problems</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../advanced/index.html">Advanced Features</a></li>
</ul>
</li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Examples</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/cvxpy.html">API Documentation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../faq/index.html">FAQ</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../citing/index.html">Citing CVXPY</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../related_projects/index.html">Related Projects</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../updates/index.html">Changes to CVXPY</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../short_course/index.html">CVXPY Short Course</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../license/index.html">License</a></li>
</ul>


<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script><div>
    <h3>
        Version selector
    </h3>
    <select id="dynamic_selector" name="versions" onchange="if (this.value) window.location.href=this.value">
    </select>
    <script>
        obj = $.getJSON("https://raw.githubusercontent.com/cvxpy/cvxpy/gh-pages/versions.json")
            .done(function (data) {
                const base_url = "https://www.cvxpy.org/"
                let html = "<option value='' selected>Choose version here</option>";
                html += "<option value=" + base_url + ">latest" + ""
                for (let i = 0; i < data.length; i++) {
                    html += "<option value=" + base_url + "version/"  + data[i] + ">" + data[i] + ""
                }
                document.getElementById("dynamic_selector").innerHTML = html;
            });
    </script>
</div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;The CVXPY authors.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/tutorial/dqcp/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    
    <a href="https://github.com/cvxpy/cvxpy" class="github">
        <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"  class="github"/>
    </a>
    

    
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-50248335-1']);
      _gaq.push(['_setDomainName', 'none']);
      _gaq.push(['_setAllowLinker', true]);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
    
  </body>
</html>